<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Vue.js Start]]></title>
      <url>%2F2017%2F01%2F20%2FVue-js-Start%2F</url>
      <content type="text"><![CDATA[Vue.js 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。 如果你是有经验的前端开发者，想知道 Vue.js 与其它库/框架的区别，查看对比其它框架。 废话不再多少，我们来看一下如何使用 Vue-cli 生成项目架构 在开始此教程前，请确保您的电脑已经装了Node.js如果没有安装，请自行安装Node.js安装 安装完Node.js之后我们可以在命令行中输入 node-v 可以查看node版本 1、 安装vue-cli 我们使用npm进行安装 npm install -g vue-cli 使用命令行进入工作去文件夹 如图 1-1： 然后在当前目录输入 npm install -g vue-cli 等待大约一分钟安装成功 2、 使用vue-cli初始化项目 命令行继续输入 vue init webpack vue-demo 如图1-2： Project name 默认是你输入命令行里的项目名称 Project description 是项目的描述 这里我们使用了ESLint 进行规范代码 我没有使用任何单元测试，其实在实际开发中很少会去自己写测试用例，反正我不会写，嘿嘿~~ 3、进入刚刚创建的项目目录 cd vue-demo 4、安装项目所需的依赖 npm install 等待安装依赖包 5、开始运行 使用命令npm run dev 不出意外的话你已经在浏览器中看到了刚刚创建的项目了 如果报错，那就是你的端口被占用了，可以去修改本项目的端口。 修改方法如下： 使用你喜欢的编辑器（我使用的是webstorm）打开该项目 打开config文件夹里的index.js文件 如图1-3所示： 红色框里就是当前的端口号，可以改成其他端口号，只要不被占用就行 有兴趣的朋友可以研究一下项目中的配置文件 对于webpack不熟悉的同学可以看一下入门Webpack，看这篇就够了 到现在为止我们已经掌握了vue的第一步 转载请注明出处 https://dongsipan.github.io/2017/01/20/Vue-js-Start/ 作者 dongsipan 2017-01-20 10:40:03]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[web端跨域调用webapi]]></title>
      <url>%2F2017%2F01%2F19%2Fweb%E7%AB%AF%E8%B7%A8%E5%9F%9F%E8%B0%83%E7%94%A8webapi%2F</url>
      <content type="text"><![CDATA[在做Web开发中，常常会遇到跨域的问题，到目前为止，已经有非常多的跨域解决方案。通过自己的研究以及在网上看了一些大神的博客，写了一个Demo首先新建一个webapi的程序，如下图所示：由于微软已经给我们搭建好了webapi的环境，所以我们不必去添加引用一些dll，直接开始写代码吧。 因为这只是做一个简单的Demo，并没有连接数据库。第一步我们要在Models文件夹里添加一个实体类Employees,用来存放数据。 Employees.cs里的内容如下： using System; using System.Collections.Generic; using System.Linq; using System.Web; namespace APIApplication.Models { public class Employees { public int? Id { get; set; } public int? DepartmentId { get; set; } public string Name { get; set; } public string Job { get; set; } public string Gender { get; set; } public string PhoneNum { get; set; } public string EmailAdderss { get; set; } public string Address { get; set; } } } 添加完实体类之后我们的重头戏即将开始，那就是controller接着我们在Controller文件夹下新建一个控制器，取名叫EmployeesController注意在添加控制器的时候要选择空API控制器模板如图所示：在控制器里我们要添加如下代码：在添加代码之前我们要添加引用： using APIApplication.Models; static List&lt; Employees&gt; emps; static EmployeesController() { emps = new List&lt; Employees&gt;(); emps.Add( new Employees { Id = 1, DepartmentId = 1, Name = &quot;张三&quot;, Gender = &quot;男&quot; , Job = &quot;ASP.NET工程师&quot; , PhoneNum = &quot;18860922483&quot;, EmailAdderss = &quot;zhangsan@123.com&quot; , Address = &quot;江苏省苏州市独墅湖大道228号&quot; }); emps.Add( new Employees { Id = 2, DepartmentId = 2, Name = &quot;李四&quot;, Gender = &quot;女&quot; , Job = &quot;web前端工程师&quot; , PhoneNum = &quot;18860922483&quot;, EmailAdderss = &quot;lisi@123.com&quot; , Address = &quot;江苏省苏州市独墅湖大道228号&quot; }); } 这段代码的作用就是往实体Employees类里存储数据。这里我只添加了两条数据仅供大家参考。 接下来我们要实现CRUD功能： public IEnumerable &lt;Employees &gt; Get(int ? id = null) { return from employee in emps where employee.Id.Equals(id) || string.IsNullOrEmpty(Convert .ToString(id)) select employee; } public void Post( Employees employee) { employee.Id = 3; emps.Add(employee); } public void Put( Employees employee) { emps.Remove(emps.Where(e =&gt; e.Id == employee.Id).First()); emps.Add(employee); } public void Delete( int id) { emps.Remove(emps.Where(e =&gt; e.Id == id).FirstOrDefault()); } 在这里Get是获取员工传入参数id是返回的就是对应id的数据，为空就是全部数据Post是添加数据Put是修改数据Put比较特殊，它在执行修改的时候是根据修改数据的ID去查找这条数据，然后删除掉，在添加新的数据。Delete当然就是删除了。 接下来是见证奇迹的时刻。我们点击运行，在浏览器里输入localhost:**/api/employees然后我们会看到一个XML的文档如下图所示： 到此我们完成了几个基本的WebApi的Get方法。今天我们讲的是跨域调用WebApi什么是跨域呢？JavaScript出于安全方面的考虑，不允许跨域调用其他页面的对象。通常来说,跨域分为以下几类： 在跨域问题上，域仅仅是通过“URL的首部”来识别而不会去尝试判断相同的ip地址对应着两个域或两个域是否在同一个ip上。想详细了解跨域的同学可以访问：http://twlidong.github.io/blog/2013/12/22/kua-yuan-zi-yuan-gong-xiang-cross-origin-resource-sharing-cors/ 了解了跨域之后我们要开始继续往下看了。web端调用api分为前端调用即（AJAX）后端调用即（.net）我先从AJAX开始讲如何实现跨域首先新建MVC项目，这里我就不截图了，相信大家都会的。这里我们用Jquery的ajax()方法，mvc默认会帮我们引入jquery我们只需要写如下代码就可以了： $(document).ready( function () { $.ajax({ type: ‘GET’, url: ‘http://localhost:7974/api/employees/get‘, dataType: ‘JSON’, success: function (data) { alert( “姓名：” + data[0].Name + “ 性别：” + data[0].Gender + “ 住址：” + data[0].Address); } }); }) 这里的url是你的api的地址映射/api/employee/get是调用get方法获取所有数据为了方便演示我就把获取的数据alert出来了 按照我的步骤你们一定没有成功吧？大家思考一下为什么会出现如下错误信息 在这里跟大家解释一下 Access-Control-Allow-Origin是HTML5中定义的一种服务器端返回Response header，用来解决资源（比如字体）的跨域权限问题。当Access-Control-Allow-Origin后面跟URL 或 ，如果是 URL 则只会允许来自该 URL 的请求， 则允许任何域的请求例如：header(‘Access-Control-Allow-Origin:http://A.abc.com&#39;)||header(&#39;Access-Control-Allow-Origin:*‘)意思是说只有当你请求的资源被允许跨域的时候才可以被访问。那么我们该怎么设置Access-Control-Allow-Origin呢？带着这个问题我么能继续我们的教程为了解决跨域问题我们要自定义一个CrossSite的属性在项目根目录新建一个类 using System.Web; using System.Web.Http.Filters; using System.Web.Mvc; namespace APIApplication { public class CrossSiteAttribute : System.Web.Http.Filters.ActionFilterAttribute { private const string Origin = &quot;Origin&quot;; /// &lt;summary&gt; /// Access-Control-Allow-Origin是HTML5中定义的一种服务器端返回Response header，用来解决资源（比如字体）的跨域权限问题。 /// &lt;/summary&gt; private const string AccessControlAllowOrigin = &quot;Access-Control-Allow-Origin&quot; ; /// &lt;summary&gt; /// originHeaderdefault的值可以使 URL 或 *，如果是 URL 则只会允许来自该 URL 的请求，* 则允许任何域的请求 /// &lt;/summary&gt; private const string originHeaderdefault = &quot;http://192.168.13.7:8002&quot; ; /// &lt;summary&gt; /// 该方法允许api支持跨域调用 /// &lt;/summary&gt; /// &lt;param name=&quot;actionExecutedContext&quot;&gt; 初始化 System.Web.Http.Filters.HttpActionExecutedContext 类的新实例。&lt;/param&gt; public override void OnActionExecuted( HttpActionExecutedContext actionExecutedContext) { actionExecutedContext.Response.Headers.Add(AccessControlAllowOrigin, originHeaderdefault); } } } 然后我们可以在EmployeesController中添加[CrossSite]属性用法是这样的： [CrossSite] public IEnumerable&lt;Employees &gt; Get(int ? id = null ) { return from employee in emps where employee.Id.Equals(id) || string.IsNullOrEmpty(Convert .ToString(id)) select employee; } 然后重新生成解决方案，运行后可以看到刚才的警告框的数据了。 前端的调用已经结束了，下面让我们看看后端是如何调用的吧。在MVC项目里的Models里我们需要一个实体模型用来读取或设置数据新建类命名为v_employees public class v_employees { public int? id { get; set; } public int? departmentid { get; set; } public string name { get; set; } public string job { get; set; } public string gender { get; set; } public string phonenum { get; set; } public string emailadderss { get; set; } public string address { get; set; } } 后端我采用的是HttpClient具体用法如下： private HttpClient client = new HttpClient (); private string url = &quot;http://192.168.13.7:8001/api/employees/get&quot; ; public async Task&lt; ActionResult&gt; Index() { ViewBag.Message = &quot;Modify this template to jump-start your ASP.NET MVC application.&quot;; var data = await client.GetAsync(url); var employees = data.Content.ReadAsAsync&lt;IEnumerable &lt;v_employees &gt;&gt;(); List&lt; v_employees&gt; emps = employees.Result.ToList(); ViewData[ &quot;employees&quot;] = emps; return View(); } 然后在Index页面设置ViewData 在页面里就可以直接使用数据emps了 @foreach ( var item in emps) { &lt;ul &gt; &lt;li &gt;@ item.name&lt;/ li&gt; &lt;li &gt;@ item.gender&lt;/li &gt; &lt;li &gt;@ item.address&lt;/li &gt; &lt;/ul &gt; } 运行后的效果如下：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2017%2F01%2F19%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
